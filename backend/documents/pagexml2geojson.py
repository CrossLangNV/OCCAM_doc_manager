from typing import Tuple, List

from lxml import etree


class Coords:
    def __init__(self, w0: float, h0: float, w1: float, h1: float,
                 l_co: List[Tuple[float]] = None):
        self.w0 = float(w0)
        self.h0 = float(h0)
        self.w1 = float(w1)
        self.h1 = float(h1)

        self.l_co = list(map(lambda a: tuple(map(float, a)), l_co))

    @classmethod
    def from_text_region_lxml(cls, element, xmlns):
        coords = _get_unique_lxml_child(element, './/{%s}Coords' % xmlns)

        s_l_co = coords.attrib.get('points')

        l_co = [tuple(map(float, s_co_i.split(','))) for s_co_i in s_l_co.strip().replace('  ', ' ').split(' ')]

        w = list(map(lambda xy: xy[0], l_co))
        h = list(map(lambda xy: xy[1], l_co))

        w0 = min(w)
        h0 = min(h)
        w1 = max(w)
        h1 = max(h)

        return cls(w0, h0, w1, h1, l_co=l_co)


def lxml_text_region_iterator(filename):
    p = PageXMLProcessor(filename)

    for textline in p.textline_generator():
        co = p.get_co(textline)
        text_textline = p.get_text(textline)

        yield co, text_textline


def lxml_text_region_iterator_trans(filename,
                                    target: str):
    """
    get all the text from the textlines after translation

    target: Language
    """

    p = PageXMLProcessor(filename)

    for textline in p.textline_generator():
        co = p.get_co(textline)
        text_textline = p.get_text_trans(textline, target=target)

        yield co, text_textline


class PageXMLProcessor:
    namespace = {'page-1': 'http://schema.primaresearch.org/PAGE/gts/pagecontent/2013-07-15',
                 }

    def __init__(self, filename,
                 validate=False):
        parser = etree.XMLParser(remove_blank_text=True)
        self.element_tree = etree.parse(filename,
                                        parser)

        self.xmlns = self.element_tree.getroot().tag.split('}')[0].strip('{')

        if validate and (self.xmlns in self.namespace.values()):
            raise LookupError(f'Xmlns not recognised.\n{self.xmlns} not in {self.namespace.values()}')

    def textline_generator(self):
        """
        Iterates over <TextLine> elements
        returns lxml elements
        """

        for region in self.element_tree.iterfind('.//{%s}TextRegion' % self.xmlns):
            # region

            for textline in region.iterfind(
                    './/{{{xmlns}}}TextLine'.format(xmlns=self.xmlns)
            ):
                yield textline

    def get_co(self, textline) -> Coords:
        """
        Textline: as generated by self.textline_generator()
        returns: a Coords object
        """

        co = Coords.from_text_region_lxml(textline, self.xmlns)
        return co

    def get_text(self, textline) -> str:
        """
        Textline: as generated by self.textline_generator()
        returns: the text contained in the textline
        """

        text_textline = _get_text_from_text_region_lxml(textline, self.xmlns)
        return text_textline

    def get_text_trans(self, textline, target) -> str:
        """
        Textline: as generated by self.textline_generator()
        target: language code of target language as saved in the XML.

        returns: the text contained in the textline
        """

        text_textline = _get_text_trans_from_text_region_lxml(textline, self.xmlns, target)
        return text_textline


def _get_text_from_text_region_lxml(element, xmlns):
    path = './/{{{xmlns}}}TextEquiv/{{{xmlns}}}Unicode'.format(xmlns=xmlns)

    unicode = _get_unique_lxml_child(element, path)
    unicode_text = unicode.text
    return unicode_text.strip() if unicode_text else ''


def _get_text_trans_from_text_region_lxml(element, xmlns, target):
    # path = './/{{{xmlns}}}TextEquiv/{{{xmlns}}}trans-unit/{{{xmlns}}}target'.format(xmlns=xmlns)
    path = ".//{{{xmlns}}}TextEquiv/" \
           "{{{xmlns}}}trans-unit/" \
           "{{{xmlns}}}target[" \
           "@{{http://www.w3.org/XML/1998/namespace}}lang='{target}'" \
           "]".format(xmlns=xmlns,
                      target=target)
    target_el = _get_unique_lxml_child(element, path)
    target_text = target_el.text
    return target_text.strip() if target_text else ''


def _get_unique_lxml_child(element, path):
    a = list(element.iterfind(path))

    assert len(a) == 1, f'Should only find one {path} element: {a}'

    b = a[0]

    return b


def main(filename,
         b_rectangle=False,
         target=None):
    """
    filename: Can be path to page XML or file object.
    target: (Optional) language code of translated language (for multilingual page xml).
    """
    if target is not None:
        lxml_text_region_iterator_trans(filename, target=target)
    else:
        l = lxml_text_region_iterator(filename)

    d = {"type": "FeatureCollection",
         'features': []}

    for co, text_textline in l:

        feature = {"type": "Feature",
                   }

        # Geometry
        if b_rectangle:
            h0, w0, h1, w1 = co.h0, co.w0, co.h1, co.w1

            feature["geometry"] = {
                "type": "Rectangle",
                "coordinates": [h0, w0, h1, w1]
            }
        else:
            feature["geometry"] = {
                "type": "Polygon",
                "coordinates": [(h, w) for (w, h) in co.l_co]
            }

        feature["properties"] = {
            "name": text_textline
        }

        d.get('features').append(feature)

    return d
